<!DOCTYPE html>
<html lang="th">
<head>
    <title>นักรบโภชนาการ VR</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <style>
        body {
            margin: 0;
            font-family: 'Inter', sans-serif; /* ใช้ฟอนต์ที่อ่านง่าย */
            background-color: #111;
            color: #fff;
            overflow: hidden; /* ป้องกันการเลื่อนหน้าจอ */
            cursor: crosshair; /* เปลี่ยนเคอร์เซอร์เป็นเป้าเล็ง */
        }
        canvas {
            display: block;
        }
        #ui {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            z-index: 10;
            pointer-events: none; /* ทำให้ UI ไม่บังการคลิกใน VR */
        }
        .score {
            font-size: 5vw; /* ขนาดตัวอักษรปรับตามความกว้างจอ */
            font-weight: bold;
            text-shadow: 0 0 10px rgba(0, 0, 0, 0.7);
        }
        .combo {
            font-size: 4vw;
            font-weight: bold;
            color: #ffc107; /* สีเหลืองอำพัน */
            text-shadow: 0 0 8px rgba(255, 193, 7, 0.8);
            margin-top: 10px;
            transition: transform 0.1s ease-out;
            transform: scale(0); /* ซ่อนไว้ตอนเริ่มต้น */
        }
        .powerup-status {
            font-size: 2.5vw;
            position: absolute;
            bottom: 15%;
            background-color: rgba(0, 0, 0, 0.6);
            padding: 5px 15px;
            border-radius: 10px;
            color: #00BFFF;
            text-shadow: 0 0 5px #00BFFF;
            opacity: 0;
            transition: opacity 0.3s ease-in-out;
        }
        .message {
            font-size: 3vw;
            margin-top: 20px;
            background-color: rgba(0, 0, 0, 0.5);
            padding: 10px 20px;
            border-radius: 15px;
            line-height: 1.5;
        }
        #VRButton {
            position: absolute !important;
            bottom: 20px !important;
            right: 20px !important;
            z-index: 100;
        }
    </style>
    <!-- โหลด Google Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap" rel="stylesheet">
</head>
<body>
    <div id="ui">
        <div id="score" class="score">คะแนน: 0 | เวลา: 30</div>
        <div id="combo" class="combo"></div> <!-- UI สำหรับคอมโบ -->
        <div id="powerup-status" class="powerup-status"></div> <!-- UI สำหรับ Power-up -->
        <div id="message" class="message">คลิก หรือ กดปุ่ม Trigger<br>เพื่อเริ่มเกม!</div>
    </div>

    <script type="module">
        import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.module.js';
        import { VRButton } from 'https://cdn.jsdelivr.net/npm/three@0.128.0/examples/jsm/webxr/VRButton.js';
        import * as Tone from 'https://cdn.jsdelivr.net/npm/tone@14.7.77/build/Tone.js';

        // --- การตั้งค่าพื้นฐาน ---
        let camera, scene, renderer;
        let controller1, controller2;
        let saber1, saber2;

        // --- ตัวแปรสำหรับเมาส์และคีย์บอร์ด ---
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        
        // --- ตัวแปรสำหรับเสียง ---
        let hitGoodSound, hitBadSound, startSound, powerupSound, backgroundMusic;
        let isAudioReady = false;
        let isInitializingAudio = false; // NEW: ป้องกันการกดเริ่มซ้ำซ้อน

        // --- ตัวแปรสำหรับเกม ---
        const foods = [];
        const particles = []; 
        let score = 0;
        let isPlaying = false;
        let spawnTimeout;
        let gameTimer;
        let remainingTime = 0;
        const GAME_DURATION = 30;
        
        // --- ตัวแปรสำหรับระบบใหม่ ---
        let comboCount = 0;
        let gameSpeedMultiplier = 1;
        let scoreMultiplier = 1;
        let slowMotionTimer, multiplierTimer;
        let highScore = 0;

        init();
        animate();
        
        function init() {
            highScore = parseInt(localStorage.getItem('nutritionWarriorHighScore') || '0');
            
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x201547);
            scene.fog = new THREE.Fog(0x201547, 5, 20);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 1.6, 2);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.xr.enabled = true;
            document.body.appendChild(renderer.domElement);

            document.body.appendChild(VRButton.createButton(renderer));

            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(5, 10, 7.5);
            scene.add(directionalLight);

            const floorGeometry = new THREE.PlaneGeometry(20, 20, 20, 20);
            const floorMaterial = new THREE.MeshStandardMaterial({ color: 0x444444, wireframe: true });
            const floor = new THREE.Mesh(floorGeometry, floorMaterial);
            floor.rotation.x = -Math.PI / 2;
            scene.add(floor);
            
            function onControllerConnected(controller) {
                controller.addEventListener('selectstart', handleUserInteraction);
            }
            controller1 = renderer.xr.getController(0);
            controller1.addEventListener('connected', () => onControllerConnected(controller1));
            scene.add(controller1);

            controller2 = renderer.xr.getController(1);
            controller2.addEventListener('connected', () => onControllerConnected(controller2));
            scene.add(controller2);

            const saberGeometry = new THREE.CylinderGeometry(0.02, 0.02, 0.8, 32);
            
            const saberMaterial1 = new THREE.MeshStandardMaterial({ color: 0x22aaff, emissive: 0x22aaff, emissiveIntensity: 1 });
            saber1 = new THREE.Mesh(saberGeometry, saberMaterial1);
            saber1.rotation.x = -Math.PI / 2;
            controller1.add(saber1);

            const saberMaterial2 = new THREE.MeshStandardMaterial({ color: 0xff2255, emissive: 0xff2255, emissiveIntensity: 1 });
            saber2 = new THREE.Mesh(saberGeometry, saberMaterial2);
            saber2.rotation.x = -Math.PI / 2;
            controller2.add(saber2);

            window.addEventListener('resize', onWindowResize, false);
            window.addEventListener('mousedown', handleUserInteraction, false);
        }
        
        function setupSounds() {
            const synthOptions = { oscillator: { type: 'sine' }, envelope: { attack: 0.005, decay: 0.1, sustain: 0.3, release: 1 } };
            hitGoodSound = new Tone.Synth(synthOptions).toDestination();
            hitBadSound = new Tone.Synth({ oscillator: { type: 'square' }, envelope: { attack: 0.005, decay: 0.2, sustain: 0, release: 0.2 } }).toDestination();
            startSound = new Tone.Synth({ oscillator: { type: 'triangle' }, envelope: { attack: 0.01, decay: 0.1, sustain: 0.1, release: 0.1 } }).toDestination();
            powerupSound = new Tone.Synth({ oscillator: { type: 'sawtooth' }, envelope: { attack: 0.01, decay: 0.2, sustain: 0.2, release: 0.2 } }).toDestination();

            const musicSynth = new Tone.Synth().toDestination();
            backgroundMusic = new Tone.Sequence((time, note) => {
                musicSynth.triggerAttackRelease(note, "8n", time);
            }, ["C3", "E3", "G3", "B3", "C4", "E4", "G4", "B4"], "4n").start(0);
            Tone.Transport.bpm.value = 130;
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // FIXED: ปรับปรุงกระบวนการเริ่มเกมทั้งหมดให้ทนทานต่อข้อผิดพลาด
        function handleUserInteraction(event) {
            // ถ้าเกมกำลังเล่นอยู่ และเป็นการคลิกเมาส์ ให้จัดการการฟันอาหาร
            if (isPlaying && event && event.type === 'mousedown') {
                mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
                mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;
                handleMouseCollision();
                return;
            }

            // ถ้าเกมยังไม่เริ่ม หรือจบไปแล้ว
            if (!isPlaying) {
                if (!isAudioReady) {
                    // ป้องกันการเรียกซ้ำขณะกำลังโหลดเสียง
                    if (isInitializingAudio) return;
                    isInitializingAudio = true;

                    const messageEl = document.getElementById('message');
                    messageEl.innerHTML = "กำลังเริ่ม...";
                    
                    Tone.start().then(() => {
                        setupSounds();
                        isAudioReady = true;
                        startGame();
                    }).catch(error => {
                        console.error("ไม่สามารถเริ่มระบบเสียงได้:", error);
                        // เริ่มเกมโดยไม่มีเสียง
                        isAudioReady = true; // ตั้งค่าเป็น true เพื่อไม่ให้พยายามเริ่มเสียงอีก
                        startGame();
                    }).finally(() => {
                        isInitializingAudio = false;
                    });
                } else {
                    // การเริ่มเกมครั้งถัดๆ ไป
                    startGame();
                }
            }
        }

        function startGame() {
            if (isPlaying) return;
            
            // FIXED: ตรวจสอบก่อนเล่นเสียง
            if (isAudioReady && startSound) {
                startSound.triggerAttackRelease("C4", "8n");
                Tone.Transport.start();
            }
            
            if (spawnTimeout) clearTimeout(spawnTimeout);
            if (gameTimer) clearTimeout(gameTimer);
            if (slowMotionTimer) clearTimeout(slowMotionTimer);
            if (multiplierTimer) clearTimeout(multiplierTimer);

            foods.forEach(food => scene.remove(food));
            foods.length = 0;

            isPlaying = true;
            score = 0;
            comboCount = 0;
            gameSpeedMultiplier = 1;
            scoreMultiplier = 1;
            remainingTime = GAME_DURATION;
            updateScoreUI();
            updateComboUI();
            hidePowerupStatus();
            document.getElementById('message').style.display = 'none';

            scheduleNextSpawn();
            gameTimer = setTimeout(endGame, GAME_DURATION * 1000);
        }

        function endGame() {
            isPlaying = false;
            clearTimeout(spawnTimeout);
            clearTimeout(gameTimer);
            clearTimeout(slowMotionTimer);
            clearTimeout(multiplierTimer);
            
            // FIXED: ตรวจสอบก่อนหยุดเสียง
            if (isAudioReady && Tone.Transport.state === "started") {
                Tone.Transport.stop();
            }
            
            if (score > highScore) {
                highScore = score;
                localStorage.setItem('nutritionWarriorHighScore', highScore);
            }

            const messageEl = document.getElementById('message');
            messageEl.innerHTML = `เกมจบแล้ว! คะแนน: ${score}<br>สถิติสูงสุด: ${highScore}<br>คลิก หรือ กด Trigger เพื่อเล่นอีกครั้ง`;
            messageEl.style.display = 'block';
            document.getElementById('combo').style.transform = 'scale(0)';
            hidePowerupStatus();
        }

        function scheduleNextSpawn() {
            if (!isPlaying) return;
            const progress = 1 - (remainingTime / GAME_DURATION);
            const minInterval = 300;
            const maxInterval = 1000;
            const interval = maxInterval - (maxInterval - minInterval) * progress;
            
            spawnTimeout = setTimeout(() => {
                spawnFood();
                scheduleNextSpawn();
            }, interval);
        }
        
        function spawnFood() {
            if (!isPlaying) return;
            const rand = Math.random();
            let food;
            const speed = 0.03 + Math.random() * 0.04;

            if (rand < 0.04) {
                const geometry = new THREE.IcosahedronGeometry(0.18, 0);
                const material = new THREE.MeshStandardMaterial({ color: 0xFFD700, emissive: 0xFFD700, emissiveIntensity: 0.5 });
                food = new THREE.Mesh(geometry, material);
                food.userData = { type: 'golden', points: 50, speed: speed + 0.03 };
            } else if (rand < 0.12) {
                const geometry = new THREE.SphereGeometry(0.15, 16, 16);
                const material = new THREE.MeshStandardMaterial({ color: 0x222222, emissive: 0xff0000, emissiveIntensity: 0.4 });
                food = new THREE.Mesh(geometry, material);
                food.userData = { type: 'bomb', points: -25, speed: speed };
            } else if (rand < 0.17) {
                const geometry = new THREE.TorusGeometry(0.12, 0.04, 8, 24);
                const material = new THREE.MeshStandardMaterial({ color: 0x00BFFF, emissive: 0x00BFFF, emissiveIntensity: 0.7 });
                food = new THREE.Mesh(geometry, material);
                food.userData = { type: 'slowmo', points: 0, speed: speed };
            } else if (rand < 0.22) {
                const geometry = new THREE.TetrahedronGeometry(0.15, 0);
                const material = new THREE.MeshStandardMaterial({ color: 0x9400D3, emissive: 0x9400D3, emissiveIntensity: 0.8 });
                food = new THREE.Mesh(geometry, material);
                food.userData = { type: 'multiplier', points: 0, speed: speed };
            } else if (rand < 0.45) {
                const geometry = new THREE.BoxGeometry(0.2, 0.2, 0.2);
                const material = new THREE.MeshStandardMaterial({ color: 0x8B4513 });
                food = new THREE.Mesh(geometry, material);
                food.userData = { type: 'bad', points: -5, speed: speed };
            } else {
                const geometry = new THREE.SphereGeometry(0.15, 16, 16);
                const colors = [0x00ff00, 0xffff00, 0xffa500];
                const color = colors[Math.floor(Math.random() * colors.length)];
                const material = new THREE.MeshStandardMaterial({ color: color });
                food = new THREE.Mesh(geometry, material);
                food.userData = { type: 'good', points: 10, speed: speed };
            }

            food.position.x = (Math.random() - 0.5) * 5;
            food.position.y = 1 + Math.random() * 1.5;
            food.position.z = -12;
            food.rotation.x = Math.random() * Math.PI;
            food.rotation.y = Math.random() * Math.PI;

            scene.add(food);
            foods.push(food);
        }
        
        function updateScoreUI() {
            document.getElementById('score').textContent = `คะแนน: ${score} | เวลา: ${Math.ceil(remainingTime)}`;
        }
        
        function updateComboUI() {
            const comboEl = document.getElementById('combo');
            if (comboCount > 2) {
                comboEl.textContent = `COMBO x${comboCount}!`;
                comboEl.style.transform = 'scale(1)';
            } else {
                comboEl.style.transform = 'scale(0)';
            }
        }
        
        function showPowerupStatus(text, color) {
            const statusEl = document.getElementById('powerup-status');
            statusEl.textContent = text;
            statusEl.style.color = color;
            statusEl.style.textShadow = `0 0 5px ${color}`;
            statusEl.style.opacity = '1';
        }
        function hidePowerupStatus() {
             document.getElementById('powerup-status').style.opacity = '0';
        }

        function activateSlowMotion() {
            if (isAudioReady && powerupSound) powerupSound.triggerAttackRelease("A4", "4n");
            gameSpeedMultiplier = 0.3; 
            showPowerupStatus("SLOW MOTION!", "#00BFFF");
            if (slowMotionTimer) clearTimeout(slowMotionTimer);
            slowMotionTimer = setTimeout(() => {
                gameSpeedMultiplier = 1; 
                hidePowerupStatus();
            }, 5000);
        }

        function activateMultiplier() {
            if (isAudioReady && powerupSound) powerupSound.triggerAttackRelease("G4", "4n");
            scoreMultiplier = 2;
            showPowerupStatus("SCORE x2 !", "#9400D3");
            if (multiplierTimer) clearTimeout(multiplierTimer);
            multiplierTimer = setTimeout(() => {
                scoreMultiplier = 1;
                hidePowerupStatus();
            }, 7000);
        }
        
        function createExplosion(position, color) {
            for (let i = 0; i < 15; i++) {
                const particleGeometry = new THREE.BoxGeometry(0.02, 0.02, 0.02);
                const particleMaterial = new THREE.MeshBasicMaterial({ color: color });
                const particle = new THREE.Mesh(particleGeometry, particleMaterial);
                particle.position.copy(position);
                particle.userData.velocity = new THREE.Vector3(
                    (Math.random() - 0.5) * 0.5, (Math.random() - 0.5) * 0.5, (Math.random() - 0.5) * 0.5
                );
                particle.userData.life = 1;
                particles.push(particle);
                scene.add(particle);
            }
        }

        function onFoodHit(food) {
            const comboMultiplier = Math.max(1, Math.floor(comboCount / 5));
            createExplosion(food.position, food.material.color);

            if (food.userData.type === 'good' || food.userData.type === 'golden') {
                comboCount++;
                score += food.userData.points * comboMultiplier * scoreMultiplier;
                if(isAudioReady && hitGoodSound) hitGoodSound.triggerAttackRelease(food.userData.type === 'golden' ? "C6" : "C5", "8n");
            } else if (food.userData.type === 'slowmo') {
                activateSlowMotion();
            } else if (food.userData.type === 'multiplier') {
                activateMultiplier();
            } else { // bad, bomb
                comboCount = 0;
                score += food.userData.points;
                if(isAudioReady && hitBadSound) hitBadSound.triggerAttackRelease("C3", "8n");
            }

            updateScoreUI();
            updateComboUI();

            const index = foods.indexOf(food);
            if (index > -1) foods.splice(index, 1);
            
            scene.remove(food);
        }

        function handleMouseCollision() {
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(foods);
            if (intersects.length > 0) {
                onFoodHit(intersects[0].object);
            }
        }
        
        function handleVRCollisions() {
            const sabers = [saber1, saber2];
            sabers.forEach(saber => {
                if (!saber.parent.visible) return;
                const saberPosition = new THREE.Vector3();
                saber.getWorldPosition(saberPosition);
                for (let i = foods.length - 1; i >= 0; i--) {
                    const food = foods[i];
                    if (saberPosition.distanceTo(food.position) < 0.25) {
                        onFoodHit(food);
                    }
                }
            });
        }
        
        function animateParticles(deltaTime) {
            for (let i = particles.length - 1; i >= 0; i--) {
                const p = particles[i];
                p.userData.life -= deltaTime * 1.5;
                if (p.userData.life <= 0) {
                    scene.remove(p);
                    particles.splice(i, 1);
                } else {
                    p.position.add(p.userData.velocity);
                    p.material.opacity = p.userData.life;
                    p.material.transparent = true;
                }
            }
        }

        function animate() {
            renderer.setAnimationLoop(render);
        }
        
        let lastTime = 0;
        function render(time) {
            const deltaTime = lastTime > 0 ? (time - lastTime) / 1000 : 0;
            lastTime = time;

            if (isPlaying) {
                if (remainingTime > 0) {
                    const prevRemainingTime = remainingTime;
                    remainingTime = Math.max(0, remainingTime - deltaTime);
                    if (Math.ceil(prevRemainingTime) !== Math.ceil(remainingTime)) {
                         updateScoreUI();
                    }
                }
            
                foods.forEach((food, index) => {
                    food.position.z += food.userData.speed * gameSpeedMultiplier;
                    food.rotation.x += 0.01;
                    food.rotation.y += 0.01;
                    if (food.position.z > camera.position.z) {
                        if(food.userData.type === 'good' || food.userData.type === 'golden') {
                           comboCount = 0;
                           updateComboUI();
                        }
                        scene.remove(food);
                        foods.splice(index, 1);
                    }
                });
                
                animateParticles(deltaTime);

                if (renderer.xr.isPresenting) {
                    handleVRCollisions();
                }
            }
            renderer.render(scene, camera);
        }
    </script>
</body>
</html>

