<!doctype html>
<html lang="th">
<head>
  <meta charset="utf-8" />
  <title>Health Quest 5 – WebXR</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    body { margin:0; overflow:hidden; font-family: system-ui, sans-serif; }
    #ui { position:fixed; top:12px; left:12px; background:#ffffffcc; padding:8px 12px; border-radius:10px; display:flex; gap:10px; align-items:center; }
    #start { padding:6px 10px; border-radius:8px; border:1px solid #888; cursor:pointer; }
    #footer { position:fixed; right:12px; bottom:12px; background:#ffffffcc; padding:6px 10px; border-radius:8px; font-size:12px; }
  </style>
</head>
<body>
  <div id="ui">
    <button id="start">Enter VR / Start</button>
    <span id="score">Score: 0</span>
    <span id="hint" style="opacity:.8;">(wave เพื่อขอคำใบ้)</span>
  </div>
  <div id="footer">Health Quest 5 • WebXR for Grade 5 • Hygiene • Nutrition • Exercise</div>

  <script type="module">
    import * as THREE from "https://cdn.jsdelivr.net/npm/three@0.165.0/build/three.module.js";
    import { VRButton } from "https://cdn.jsdelivr.net/npm/three@0.165.0/examples/jsm/webxr/VRButton.js";
    import { XRControllerModelFactory } from "https://cdn.jsdelivr.net/npm/three@0.165.0/examples/jsm/webxr/XRControllerModelFactory.js";
    import { HandGestureManager } from "./HandGestureManager.js";

    let renderer, scene, camera, hgm, score = 0;
    let reticle, grabbed = null;

    const scoreEl = document.getElementById('score');
    const startBtn = document.getElementById('start');

    init();

    function init() {
      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.xr.enabled = true;
      renderer.xr.setReferenceSpaceType('local-floor');
      document.body.appendChild(renderer.domElement);

      // VR Button
      document.body.appendChild(VRButton.createButton(renderer));

      // Scene
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0xf0fbff);

      camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.01, 50);

      // Light
      const hemi = new THREE.HemisphereLight(0xffffff, 0x444444, 1.0);
      hemi.position.set(0, 2, 0);
      scene.add(hemi);

      const dir = new THREE.DirectionalLight(0xffffff, 0.6);
      dir.position.set(2, 3, 1);
      scene.add(dir);

      // Ground
      const ground = new THREE.Mesh(
        new THREE.PlaneGeometry(20, 20),
        new THREE.MeshPhongMaterial({ color: 0xe9f7ef })
      );
      ground.rotation.x = -Math.PI/2;
      ground.position.y = 0;
      scene.add(ground);

      // Lobby sign
      const lobby = makeBillboard("Health Plaza
เลือกการ์ดดี/ไม่ดี แล้วโยนลงถังให้ถูก");
      lobby.position.set(0, 1.6, -2.2);
      scene.add(lobby);

      // Sample cards (Hygiene)
      const goodCard = makeCard("ล้างมือก่อนกินข้าว", 0x8fe388);
      goodCard.position.set(-0.4, 1.2, -1.2);
      scene.add(goodCard);

      const badCard = makeCard("ใช้แก้วน้ำร่วมกัน", 0xffb3b3);
      badCard.position.set(0.4, 1.2, -1.2);
      scene.add(badCard);

      // Bins
      const binGood = makeBin("ถูก", 0x72d572); binGood.position.set(-1.0, 0.4, -2.0); scene.add(binGood);
      const binWrong = makeBin("ผิด", 0xff8080); binWrong.position.set( 1.0, 0.4, -2.0); scene.add(binWrong);

      // Reticle
      reticle = new THREE.Mesh(
        new THREE.RingGeometry(0.01, 0.015, 32),
        new THREE.MeshBasicMaterial({ color:0x333333, side:THREE.DoubleSide })
      );
      reticle.position.set(0, 1.5, -0.8);
      reticle.lookAt(new THREE.Vector3(0,1.5, -2));
      scene.add(reticle);

      // Controller models (fallback)
      const controllerModelFactory = new XRControllerModelFactory();
      for (let i=0;i<2;i++){
        const controllerGrip = renderer.xr.getControllerGrip(i);
        controllerGrip.add(controllerModelFactory.createControllerModel(controllerGrip));
        scene.add(controllerGrip);
      }

      // Gesture Manager
      hgm = new HandGestureManager(renderer.xr);
      hgm.on('pinchstart', ({ hand }) => {
        grabbed = pickNearestCard();
      });
      hgm.on('pinchend', ({ hand }) => {
        if (grabbed) {
          const ok = dropIntoBin(grabbed);
          if (ok) bumpScore(10);
          grabbed = null;
        }
      });
      hgm.on('wave', ({ hand }) => {
        showHint();
      });

      // Resize
      window.addEventListener('resize', onResize);
      function onResize(){
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      }

      // Animation loop
      renderer.setAnimationLoop((t, frame) => {
        if (frame) hgm.update(frame);
        if (grabbed) {
          grabbed.position.lerp(reticle.getWorldPosition(new THREE.Vector3()), 0.35);
        }
        renderer.render(scene, camera);
      });

      // Start button -> request session with hand-tracking optional
      startBtn.addEventListener('click', async () => {
        if (!navigator.xr) { alert('WebXR not supported'); return; }
        const session = await navigator.xr.requestSession('immersive-vr', {
          optionalFeatures: ['local-floor', 'hand-tracking', 'layers']
        });
        await renderer.xr.setSession(session);
      });
    }

    // ---------- Utilities ----------
    function makeCard(label, color){
      const g = new THREE.BoxGeometry(0.28, 0.18, 0.02);
      const m = new THREE.MeshPhongMaterial({ color });
      const card = new THREE.Mesh(g, m);
      card.userData.type = (color === 0x8fe388) ? 'good' : 'bad';

      const sprite = makeTextSprite(label);
      sprite.position.set(0, 0, 0.02);
      card.add(sprite);
      return card;
    }

    function makeBin(text, color){
      const cyl = new THREE.Mesh(
        new THREE.CylinderGeometry(0.25, 0.25, 0.4, 24),
        new THREE.MeshPhongMaterial({ color, opacity:0.95, transparent:true })
      );
      const label = makeTextSprite(text, 0.18);
      label.position.set(0, 0.28, 0);
      cyl.add(label);
      cyl.userData.bin = text; // "ถูก" / "ผิด"
      return cyl;
    }

    function makeBillboard(txt){
      const mesh = new THREE.Mesh(
        new THREE.PlaneGeometry(1.5, 0.6),
        new THREE.MeshBasicMaterial({ map: textTexture(txt), transparent:true })
      );
      return mesh;
    }

    function textTexture(txt){
      const c = document.createElement('canvas');
      const ctx = c.getContext('2d');
      c.width = 1024; c.height = 512;
      ctx.fillStyle = 'rgba(255,255,255,0.9)';
      ctx.fillRect(0,0,c.width,c.height);
      ctx.fillStyle = '#111';
      ctx.font = 'bold 64px system-ui';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      const lines = txt.split('\n');
      lines.forEach((line, i)=>{
        ctx.fillText(line, c.width/2, c.height/2 + (i- (lines.length-1)/2)*80);
      });
      return new THREE.CanvasTexture(c);
    }

    function makeTextSprite(txt, scale=0.12){
      const c = document.createElement('canvas');
      const ctx = c.getContext('2d');
      c.width = 512; c.height = 256;
      ctx.fillStyle = '#ffffff';
      ctx.fillRect(0,0,c.width,c.height);
      ctx.fillStyle = '#111';
      ctx.font = 'bold 46px system-ui';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText(txt, c.width/2, c.height/2);
      const tex = new THREE.CanvasTexture(c);
      const mat = new THREE.SpriteMaterial({ map: tex });
      const spr = new THREE.Sprite(mat);
      spr.scale.set(scale*2, scale, 1);
      return spr;
    }

    function pickNearestCard(){
      let nearest = null, dMin = Infinity;
      scene.traverse(obj=>{
        if (obj.isMesh && obj.geometry?.type === 'BoxGeometry'){
          const d = obj.position.distanceTo(reticle.position);
          if (d < dMin && d < 0.6) { dMin = d; nearest = obj; }
        }
      });
      return nearest;
    }

    function dropIntoBin(card){
      let targetBin = null, dMin = Infinity;
      scene.traverse(obj=>{
        if (obj.userData?.bin){
          const d = obj.position.distanceTo(card.position);
          if (d < dMin) { dMin = d; targetBin = obj; }
        }
      });
      if (!targetBin || dMin > 0.5) return false;

      const isGood = card.userData.type === 'good';
      const dropToGood = targetBin.userData.bin === 'ถูก';
      const ok = (isGood && dropToGood) || (!isGood && !dropToGood);

      card.position.copy(targetBin.position).add(new THREE.Vector3(0,0.35,0));
      return ok;
    }

    function bumpScore(n){ score += n; scoreEl.textContent = "Score: " + score; }
    function showHint(){
      scene.traverse(obj=>{
        if (obj.isMesh && obj.geometry?.type === 'BoxGeometry' && obj.userData.type === 'good'){
          obj.material.emissive = new THREE.Color(0x33ff33);
          setTimeout(()=>{ obj.material.emissive = new THREE.Color(0x000000); }, 600);
        }
      });
    }
  </script>
</body>
</html>
